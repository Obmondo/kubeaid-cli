package logger

import (
	"io"
	"log"
	"log/slog"
	"os"

	"github.com/go-logr/logr"
	"k8s.io/klog/v2"
	controllerRuntimeLogger "sigs.k8s.io/controller-runtime/pkg/log"

	"github.com/Obmondo/kubeaid-bootstrap-script/pkg/constants"
)

// Initializes the logger.
func InitLogger(isDebugModeEnabled bool) {
	logLevel := slog.LevelInfo
	if isDebugModeEnabled {
		logLevel = slog.LevelDebug
	}

	logFile, err := os.OpenFile(constants.OutputPathLogFile,
		os.O_CREATE|os.O_WRONLY|os.O_TRUNC,
		os.ModePerm,
	)
	if err != nil {
		log.Fatal("Failed opening log file")
	}

	logger := slog.New(withContextualSlogAttributesHandler(NewCustomTextHandler(
		io.MultiWriter(logFile, os.Stdout), &slog.HandlerOptions{
			Level: logLevel,
		},
	)))
	slog.SetDefault(logger)

	// Initialize controller-runtime's (or kubebuilder's) base logger. Otherwise, it'll complain with
	// some error message.
	// We want to ignore all logs generated by the controller runtime.
	controllerRuntimeLogger.SetLogger(logr.Discard())

	/*
		We were getting ArgoCD port-forward error :

		  error copying from remote stream to local connection: readfrom tcp4
		  127.0.0.1:53214->127.0.0.1:53218: write tcp4 127.0.0.1:53214->127.0.0.1:53218: write:
		  broken pipe

		This will suppress the ArgoCD portforward error we get.
	*/
	klog.SetSlogLogger(
		slog.New(slog.DiscardHandler),
	)
}

func Error(err error) slog.Attr {
	return slog.Any("error", err)
}
